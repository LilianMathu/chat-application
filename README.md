# Publish/subscribe programming paradigm with socket.io
 <h3>Introduction</h3><br>
 <p> Socket. io is an open source, JavaScript-based framework that is packaged as a Node. js npm module. I love to use Socket. io because of the impressive features that it ships with. A few of these include reliability. Socket. io is optimized to work on every platform, browser, and device, both for mobile and desktop. Blazing speed, this feature is very important when delivering real-time updates across connected devices, as well as ease of use. Socket. io becomes very easy to implement since we're able to use the same API methods on both the client and the server. Let's take a look at what we'll be covering in this course. In this course we will cover all of the fundamentals of Socket. io. This includes the origins of Socket. io, as well as the problems that it solves, what companies are currently using Socket. io, and what are some of the products that they're using it with. Additionally, what are some of the most common use cases for including Socket. io in your next project? We'll then see how easy it is to implement Socket. io in a Node. js server, and connect to a client. Along the way we'll build two demo applications. The first will be a bitcoin tracker, and this app will display changes to bitcoin currency in real-time, using an API provided to us by btcc. com. The second will be a chat application, this will include functionality such as how to join and leave rooms, how to broadcast messages to all users, and how to send private messages to specific clients. By the time you're done with this course, you'll be capable of implementing Socket. io to perform real-time communications using Node. js and the client of your choice. You will definitely find it beneficial to code along with me, but I will also be adding the code to this course to a publicly available GitHub repo, it is called Socket. io Demos, and you can find it here at this URL.</p>
 <br>
 <h3>Prerequisites</h3><br>
<p>Before diving into this course, there are a few technologies that you should already be familiar with. You should already be familiar with the basics of JavaScript. The more you know the better, but we'll mostly be working within the confines of the Socket. io library to structure our code. You should already have Node. js installed, and be familiar with the CommonJS pattern of requiring in modules. I will be using Node version 4. 2. 3, but an earlier version such as 0. 11, or even the beta version of Node 5. 0 will work just fine. We'll be using a small amount of jQuery in this app, so it will be helpful to know something about jQuery, and we'll be using Angular as our front-end view engine for the chat application. I will be using Angular 1. 5. 3 for this course. It will also be helpful to understand some HTML and Bootstrap for styling, since we'll be using these in our demo apps.</p><br>
 
<h3>Demos</h3><br>
<p>There are two main demo apps for this course, and one basic setup demonstration. In our setup, we'll take a first look at how to create socket connections between the client and the server, and print messages to both our browser console and our Node. js console in order to show their connection. Our first main demo app will be a bitcoin tracker. We'll be using the bttc. com API to track bitcoin prices and volume in real-time. We'll then display the buy and sell bids as they come in. We'll be using jQuery to attach our buy and sell price changes to DOM elements, and Bootstrap to style the view. Our second demo app will be a chat application. Our chat application will include a login page where users can input the username of their choice. Once inside the main page, users will be able to send messages that will be received by all connected users in real-time. Users will be able to click a button to send likes to the user of their choice that will then display a message to only the selected user. We'll be using Angular version 1. 5 to handle events, and Bootstrap for our styling. So if you're ready, let's get started now by learning the basics of what makes Socket. io such an awesome framework for building real-time applications.</p><br>

<h3>Socket.io Basics</h3>
<h4>Socket.io Framework</h4>
<p>
Let's take a minute here to understand what Socket. io is, as well as where it comes from. Socket. io is a JavaScript-based framework that is built and maintained as a Node. js module. There is a heavily-starred GitHub repo that provides us with information on how to set up and use Socket. io. Examples are given on how to set it up with both Express and Koa. You can also find a list of Socket. io methods with descriptions on how to use each one of them. There is also a website which is located at Socket. io. Here you can find a few demos by clicking on the Demos link, which includes a link to the source code for each demo project. If we click here on the Docs link, we can see an area for the Server API and for the Client API. One of the best features of Socket. io is that it provides us with the same API methods that we can use for both the server, as well as the client. There is also a Slack channel that boasts an active community, as well as a blog to keep us current on the newest changes. Socket. io was not built from the ground up, instead it is based on the WebSockets technology, so let's now learn a little bit more about WebSockets, and how we can use the browser to power connected clients.
 </p><br>
<h4>Built with Websockets</h4>
<p>
 Socket. io uses the WebSocket technology as its base for real-time updates, so let's now discuss how Socket. io is derived from this WebSocket technology, what problems does Socket. io solve, and what are some of the key features Socket. io supports? Socket. io is built with Engine. io, which is an abstraction on top of the WebSockets technology, and WebSockets is a browser-based technology that was standardized for all major browsers in 2011. The WebSocket technology allows for direct two-way connections between the client and the server. This makes it easy to build real-time apps, because the server can dynamically push new data to connected clients whenever there is new data, or the state has changed. WebSockets, just like Socket. io, relies on an initial handshake between the client and the server, and once this handshake is made, data can then be freely exchanged. Socket. io was developed for two main reasons. The first was to create a simplified wrapper for creating and working with WebSocket connections. This is similar to the idea of jQuery being a simplified DOM wrapper around JavaScript. And the second reason was to eliminate some of the connection problems that naturally occurred when working with WebSockets. The solutions provided by Socket. io include built-in fallbacks for old browsers that don't support WebSockets, an AJAX long polling fallback that accounts for sites where WebSockets is turned off, and other solutions for issues that occur with missing events, and these include events such as heartbeats, timeouts, and disconnections. One of the biggest benefits of using WebSockets, and in turn Socket. io, is in its ability to scale. Sockets are joined using a single TCP connection. Normally, communication between client and server occurs with multiple HTTP requests being made every time a piece of data is retrieved or needs to be updated, but this is not the case when using WebSockets. Since the connection is left open, any updates or changes are sent directly, and this leads to a huge savings in both latency and performance. Another huge benefit of using Socket. io is that it comes with excellent cross-browser and device support, so you can expect the same speed and performance across all platforms, browsers, and connected devices, and this is based on the fact that connections are initiated and maintained within the browser window. Here is a chart from the website caniuse. com, which shows all the browsers that currently support WebSockets. Currently, 87% of the world is able to use WebSockets natively, and by using Socket. io, we're able to close the gap even more, which creates solutions for working with older browsers like IE 8 and IE 9.
</p><br>
 
<h4>Socket.io Features</h4>
<p>
 Let's now discuss what Socket. io actually does. Socket. io enables real-time, bi-directional, event-based communication. This means that users can connect to a socket. Once connected they can then send or receive data to all other connected sockets in real-time. Communication is event-based, and this means that we'll be subscribing to events, and then be able to receive any changes as they occur. You can think of this as a free-flowing stream of data between connected devices. Once the device connects to a stream using a handshake, the connection is left open so that the server can pass and receive data from any and all clients in real-time. The format that Socket. io uses to pass data back and forth is in the form for JSON. JSON stands for JavaScript Object Notation, and will look something like this, consisting of a key value pair inside of a curly bracket. As we progress through the course, you will see examples of how we can listen for, receive, and respond to events using the same methods on both the client and the server. Socket. io is optimized to work best with low latency operations. This includes uses like sending messages and pushing out data. Examples might include chat applications like Slack, real-time analytics like Google Analytics, and sending notifications that you might see in places like Twitter and Facebook. As of Socket. io version 1. 0, there is also the ability to send an image, audio, and video as a binary stream. However, we won't be dealing with this feature in this course since it's not supported by enough browsers and can be unstable.
</p><br>

<h4>Socket.io Uses</h4>
<p>There are many real-world examples of companies using real-time technologies as part of their products. A number of these are using Socket. io to power their applications. A few examples given on the Socket. io website include products like Microsoft Office, Yammer, Zendesk, and Trello. These specific use cases are focused on the ability to update documents, offer client support, and provide a chat interface. However, there are also many other uses that we can think of that currently employ or benefit from real-time updates. For example, the real-time notifications you receive when using Facebook or Twitter can be distributed using WebSockets. You can create real-time dashboards that get updated to show user data like you might see in Google Analytics. Another example is any other kind of application that can connect users across the globe, this includes multi-player games, updating scores for sporting events, gambling applications that update the amount of wages won or lost, trading applications that offer real-time updates to changes in the prices of stocks, and real-time forms for collaborative editing between groups in different locations.</p><br>

<h4>Summary</h4>
<p>In this module we learned that Socket. io is a framework that is built for Node. js, and maintained as an npm module. We discussed how Socket. io is an abstraction on top of WebSockets, and how it is used to solve a number of limitations inherent when working with WebSockets directly. We learned that when connecting to a socket, it requires just an initial handshake, then the connection is left open for data to be sent and received. We learned how Socket. io uses JSON consisting of key value pairs to transmit data. This type of data is best suited to work with Socket. io as it represents low latency operations that are small and easy to transmit through a browser. Finally, we looked at a number of products currently using Socket. io, as well as other possible use cases. A few of these included sending notifications, updating scores for sporting events, and real-time collaborative editing.<p><br>
 
 
 
 <h3>Installing Socket.io</h3>
 <h3>Introduction</h3><br>
Welcome back to Building Real-time Applications with Socket. io. In this module we'll work on two small projects to get you familiar with installing Socket. io and working with JSON data. In the first project we'll work through how to install and set up Socket. io in our local environment. We'll start off by creating a simple Node. js server using Express, then we'll require in Socket. io, and add it to both our server and client files. Once our setup is all complete, we'll print messages to our Node console and to our browser console in order to demonstrate how they are connected. In our second project, we will build an app that will track and display changes in the price of bitcoins using the Bitcoin China API. The starter code for these projects can be found here at the Socket. io Demos repository.

 <h3>Socket.io Setup</h3><br>
Let's now set up our first project using Socket. io. We'll be building a simple app to demonstrate how to create a Socket. io connection between the client and the server, and then print out messages to both the browser console and the Node console. I'm using Sublime Text as my preferred text editor for these projects, but you're welcome to use any editor that you're most familiar with. I've created a folder and named it starter. You can place this folder wherever you'd like. I'm going to navigate over to the location of this folder in my terminal and then type the command npm init. I'm going to hit Enter a few times, but you can put anything you'd like for these values. The npm init command creates for us a package. json file that we can then use to download and save npm modules. I'm going to finish creating our starter template here in my terminal by typing the command touch app. js, which creates an app. js file, then I'll create a public folder by typing mkdir public. I'm going to navigate into this folder by using cd public, and create a new file here by typing touch, and then index. html. Let's switch over now to Sublime Text to see our new folder structure. And we can see here that there's an app. js file, along with a public folder which includes our index. html file. I'm now going to require in the modules that we'll need for this project. So back in my terminal I'll cd back into the root, and next I'm going to include express, path, and socket. io by using the command npm install, along with the --save flag. Let's switch back into our editor. Once these modules are finished downloading, we should see a new folder that gets created called node_modules, and this includes the modules that we just downloaded from npm. The first thing that we'll do is open up the index. html file and create a simple scaffold. I can use the html:5 command, which uses the Emmet Sublime Text plugin for this. One pretty unusual aspect of Socket. io is that we can include it directly into our HTML file like this, referencing a file location that doesn't seem to exist, and the reason we're able to do that is because the socket. io. js file gets automatically exposed by the Socket. io server. We can dig into this a little bit more by navigating into our Socket. io Node module. So we'll open up socket. io, then node_modules to locate a socket. io-client folder. So we'll open that up and here we see a socket. io. js file, and this is what we're actually referencing within our index. html. And if we open up the README file and scroll down a bit, we can see a How to use area that explains how we're able to use Socket. io on the client side. So let's finish up our initial scaffolding of our starter app by setting up our server files. We'll go back into our app. js file and start off by requiring in our node module dependencies, express and path. We'll then set up a variable app to expose express, and I'm going to set up a server by requiring in http, and then passing in our app variable into the http server. When requiring in socket. io, we need to pass the server as a parameter. I found this to be the simplest way of setting up a Socket. io project. Let's now make a connection to our public folder by using the express. static method, and passing in path. join. And we'll also make a variable for our port number. And lastly let's test this out by listening to our server, passing in the port variable, and a function that will print a message when we run the file. So everything looks good and our server has started. In the next video we'll create our first socket connection.

 <h3>First Connection</h3><br>
With our setup in place, let's create our first connection. We'll do so by opening up our app. js file, and opening up connections using our io variable declared up above. We can use the on method provided to us by socket. io, and then specify an event known as connection. This connection string is part of the Socket. io library and does the job of opening up connections between the client and the server. We've added a socket argument here that's going to be used every time we want to send and receive messages. Let's also add a log message letting us know a new connection has been made. Now, let's set up the connection to our client. So we'll open up our index. html file, and it's very easy to initiate the connection, also known as a handshake, between our client and server. All we need to do is set a variable for our socket, and pass in our server location. And we do this inside of a script tag. We'll restart our server, and notice that we get listening on port 8080. Now if we navigate to this port in our browser, we should expect to get our new connection made message in the console. And if we open up another window, and navigate to our localhost, we'll get a new message indicating another new user has been connected. And that's all that we need to do to get Socket. io up and running.

 <h3>Send and Receive Messages</h3><br>
With our connection in place, let's now see how we can send and receive messages from the server to the client, and vice versa. We use the emit and on methods as our primary method for handling events in Socket. io. So inside of the connection event, I'll say socket. emit, and then pass a string event listener, along with a JSON object that will send a greeting message from the server. This string called message-from-server will be used on the client to display our message. And we'll also set up an on event listener that will listen for messages coming from the event named message-from-client. So we'll do the reverse on the client, and emit a message that can be picked up and displayed as a log message in our Node console. Let's switch over to our index. html file and set up our events on the client. When using Socket. io, we're able to use the same methods for both the client and the server, so I can say socket. on, and listen for the event, message-from-server, then I can declare a callback function with an event parameter that contains the JSON message hello client from server. In order to display the message in our browser, I'm going to use some vanilla JavaScript here and print the message. Let's also set up our emit event, which was called message-from-client. We'll send back a similar message to the server containing the string message, Hello from Client. Notice that when sending messages, we're doing so with an object, and when receiving messages, we're using a function that has a parameter that contains the message that we received. Now let's test this out, and to do that I'll switch back into my terminal and restart the server. And since we're sending and receiving messages within our connection event, we're going to see both messages displayed immediately. And here we can see our two messages sent from the browser to the server, and vice versa.

 <h3>The Pub/Sub Pattern</h3><br>
Now that we've seen Socket. io in action, let's take a brief moment to discuss the programming paradigm that we're using, and that is the publish/subscribe pattern, also known as the Pub/Sub pattern. At its most basic definition, the Pub/Sub pattern is a one-way messaging, events-driven manner of writing code. Essentially we have a set of subscribers that register their interest in receiving a specific category of messages, while the publisher produces messages that are then distributed across all the relevant subscribers. What makes Pub/Sub perfect for our uses is that the publisher does not need to know who the recipients are in advance. This creates a loosely coupled relationship between the publisher and the subscribers, and since the publisher doesn't need to know anything about the individual connections, this can help to create an ideal pattern for distributed systems that are able to evolve and scale. You've already seen this pattern in action. Here we are subscribing to the event message-from-client, and here we are publishing a message to all those subscribed to the event called message-from-client. We'll continue using this pattern in all future examples for every time we're sending and receiving bits of data.

